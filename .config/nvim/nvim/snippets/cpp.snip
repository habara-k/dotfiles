
###########################################################
#### MACRO                                             ####
###########################################################
snippet for
   FOR(${1:i}, ${2:0}, ${3:n}) {
      ${0}
   }
snippet fore
   FORE(${1:i}, ${2:0}, ${3:n}) {
      ${0}
   }
snippet rfor
   RFOR(${1:i}, ${2:0}, ${3:n}) {
      ${0}
   }
snippet rfore
   RFORE(${1:i}, ${2:0}, ${3:n}) {
      ${0}
   }
snippet rep
   REP(${1:i}, ${2:n}) {
      ${0}
   }

snippet all
   ALL(${1})

snippet sort
   SORT(${1})

snippet sz
   SZ(${1})

snippet each
   EACH(${1:i}, ${2:c}) {
      ${0}
   }

snippet count
   COUNT(${1}, ${2})

snippet unique
   UNIQUE(${1})

snippet copy
   COPY(${1}, ${2})

snippet exist
   EXIST(${1:s}, ${2:e})

snippet dump
   DUMP(${1})


###########################################################
#### STL DUMP                                          ####
###########################################################

snippet dump_edge
   ostream& operator << (ostream& s, const edge& e) {
      s << "(" << e.from << "->" << e.to << ": " << e.cost << ")";
      return s;
   }

snippet dump_pair
   template<typename T1, typename T2> ostream& operator << (ostream& s, const P<T1,T2>& p) {
      s << "(" << p.first << "," << p.second << ")";
      return s;
   }

snippet dump_vector
   template<typename T> ostream& operator << (ostream& s, const V<T>& v) {
      s << "[";
      for (int i = 0; i < v.size(); i++) { s << v[i]; if (i < v.size() - 1) s << " "; }
      s << "]";
      return s;
   }

snippet dump_set
   template<typename T> ostream& operator << (ostream& s, const set<T>& st) {
      s << "{";
      for (auto i = st.begin(); i != st.end(); ++i) {
         s << *i;
         if (next(i) != st.end()) s << ", ";
      }
      s << "}";
      return s;
   }

snippet dump_map
   template<typename T1, typename T2> ostream& operator << (ostream& s, const map<T1,T2>& m) {
      s << "{";
      for (auto i = m.begin(); i != m.end(); ++i) {
         s << i->first << ":" << i->second;
         if (next(i) != m.end()) s << ", ";
      }
      s << "}";
      return s;
   }


###########################################################
#### NUMBER THEORY                                     ####
###########################################################

snippet gcd
   int gcd(int x, int y) {
      if(x < y) swap(x, y);
      if(x % y == 0) {
         return y;
      } else {
         return gcd(y, x % y);
      }
   }

snippet lcm
   int lcm(int x, int y) {
      return x * y / gcd(x, y);
   }

snippet isprime
   vector<bool> isprime;
   void init_isprime(int N)
   {
      isprime.resize(N+1, true);
      isprime[0] = isprime[1] = false;
      for(int i = 2; i <= N; i++) {
         if (isprime[i]) {
            for (int j = 2; i*j <= N; j++) {
               isprime[i*j] = false;
            }
         }
      }
   }

snippet factorize
   vector<bool> isprime;
   void init_isprime(int N)
   {
      isprime.resize(N+1, true);
      isprime[0] = isprime[1] = false;
      for(int i = 2; i <= N; i++) {
         if (isprime[i]) {
            for (int j = 2; i*j <= N; j++) {
               isprime[i*j] = false;
            }
         }
      }
   }
   void factorize(map<int,int>& fact_n, int M)
   {
      int tmpM = M;
      for(int i = 2; i < isprime.size(); i++) {
         if (!isprime[i]) continue;
         while (tmpM % i == 0) {
            fact_n[i]++;
            tmpM /= i;
         }
      }
      if (tmpM != 1) fact_n[tmpM]++;
   }

snippet powM
   int powM(int x, int n) {
      int res = 1;
      while (n > 0) {
         if ((n & 1) == 1) res = mod(res * x);
         x = mod(x * x);
         n >>= 1;
      }
      return res;
   }

snippet inverseM
   int powM(int x, int n) {
      int res = 1;
      while (n > 0) {
         if ((n & 1) == 1) {
            res = mod(res * x);
         }
         x = mod(x * x);
         n >>= 1;
      }
      return res;
   }
   int inverseM(int x) {
      return powM(x, MOD-2);
   }

snippet frac
   vector<int> frac;
   void init_frac(int N) {
      frac.resize(N+1);
      frac[0] = 1;
      for (int i = 1; i <= N; i++) {
         frac[i] = mod(frac[i-1] * i);
      }
   }

snippet combination
   vector<int> frac;
   void init_frac(int N) {
      frac.resize(N+1);
      frac[0] = 1;
      for (int i = 1; i <= N; i++) {
         frac[i] = mod(frac[i-1] * i);
      }
   }
   int powM(int x, int n) {
      int res = 1;
      while (n > 0) {
         if ((n & 1) == 1) {
            res = mod(res * x);
         }
         x = mod(x * x);
         n >>= 1;
      }
      return res;
   }
   int inverseM(int x) {
      return powM(x, MOD-2);
   }
   int comb(int n, int r) {
      if (n < 0 || n-r < 0 || r < 0) {
         return 0;
      }
      return mod(frac[n] * inverseM(mod(frac[n-r]*frac[r])));
   }

snippet permutation
   vector<int> frac;
   void init_frac(int N) {
      frac.resize(N+1);
      frac[0] = 1;
      for (int i = 1; i <= N; i++) {
         frac[i] = mod(frac[i-1] * i);
      }
   }
   int powM(int x, int n) {
      int res = 1;
      while (n > 0) {
         if ((n & 1) == 1) {
            res = mod(res * x);
         }
         x = mod(x * x);
         n >>= 1;
      }
      return res;
   }
   int inverseM(int x) {
      return powM(x, MOD-2);
   }
   int perm(int n, int r) {
      if (n < 0 || n-r < 0) {
         return 0;
      }
      return mod(frac[n] * inverseM(frac[n-r]));
   }

snippet inversionP
   int inversionP(const vector<int>& p) {
      int N = p.size();
      BIT<int> bit(N);
      int res = 0;
      for (int i = 0; i < N; i++) {
         res += i - bit.sum(p[i]);
         bit.add(p[i], 1);
      }
      return res;
   }

snippet inversion
   int inversionP(const vector<int>& p) {
      int N = p.size();
      BIT<int> bit(N);
      int res = 0;
      for (int i = 0; i < N; i++) {
         res += i - bit.sum(p[i]);
         bit.add(p[i], 1);
      }
      return res;
   }
   int inversion(const vector<int>& v) {
      int N = v.size();
      vector<pair<int,int>> tmp(N);
      for (int i = 0; i < N; i++) tmp[i] = make_pair(v[i],i);
      sort(tmp.begin(),tmp.end());
      vector<int> p(N);
      for (int i = 0; i < N; i++) p[tmp[i].second] = i;
      return inversionP(p);
   }

snippet zeta
   void zeta(const vector<int>& g, vector<int>& f)
   {
      // GET f(S) = \sum_{T \subset S} g(T)
      copy(g.begin(), g.end(), f.begin());
      int n = f.size();
      for (int i = 0; (1 << i) < n; i++) {
         for (int j = 0; j < n; j++) {
            if ((j >> i) & 1) {
               f[j] += f[j ^ (1 << i)];
            }
         }
      }
   }

snippet moebius
   void moebius(const vector<int>& g, vector<int>& f)
   {
      // GET f(T), where g(S) = \sum_{T \subset S} f(T)
      copy(g.begin(), g.end(), f.begin());
      int n = f.size();
      for (int i = 0; (1 << i) < n; i++) {
         for (int j = 0; j < n; j++) {
            if ((j >> i) & 1) {
               f[j] -= f[j ^ (1 << i)];
            }
         }
      }
   }

snippet GF2
   struct GF2 {
      int n;
      GF2(int m=0) { n = m; }
      const bool operator==(int m) const { return n == (m%2); }
      const bool operator!=(int m) const { return n != (m%2); }
      const bool operator>(const GF2 a) const { return n > a.n; }
      const GF2 operator+(const GF2& a) const { return GF2{n ^ a.n}; }
      const GF2 operator-(const GF2& a) const { return GF2{n ^ a.n}; }
      const GF2 operator*(const GF2& a) const { return GF2{n * a.n}; }
      const GF2 operator/(const GF2& a) const { if (a.n == 0) throw "Can't devide by 0"; return GF2{n / a.n}; }
      GF2& operator+=(const GF2& a) { n ^= a.n; return *this; }
      GF2& operator-=(const GF2& a) { n ^= a.n; return *this; }
      GF2& operator*=(const GF2& a) { n *= a.n; return *this; }
      GF2& operator/=(const GF2& a) { if (a.n == 0) throw "Can't devide by 0"; n /= a.n; return *this; }
      GF2& operator=(int m) { n = m; return *this; }
   };
   const GF2 abs(GF2 x) { return x; }
   ostream& operator << (ostream& s, const GF2& a) { s << a.n; return s; }

###########################################################
#### BINARY SEARCH                                     ####
###########################################################

snippet binary_search_max
   int binary_search(vector<int>& a)
   {
      int m, l = -1, r = a.size();
      while (r - l > 1) {
         m = (l + r) / 2;
         if () {
            l = m;
         } else {
            r = m;
         }
      }
      return l;
   }

snippet binary_search_min
   int binary_search(vector<int>& a)
   {
      int m, l = -1, r = a.size();
      while (r - l > 1) {
         m = (l + r) / 2;
         if () {
            r = m;
         } else {
            l = m;
         }
      }
      return r;
   }


###########################################################
#### Binary Indexed Tree                               ####
###########################################################

snippet BIT
   template<typename T> class BIT
   {
      private:
         vector<T> bit;
         int len;
      public:
         BIT(int n) {
            len = n+1;
            bit.resize(len);
         }
         void add(int i, T x) {
            i += 1;
            while (i < len) {
               bit[i] += x;
               i += i & -i;
            }
         }
         int sum(int i) {
            i += 1;
            T s = 0;
            while (i > 0) {
               s += bit[i];
               i -= i & -i;
            }
            return s;
         }
   };

snippet BIT_2D
   template<typename T> class BIT_2D
   {
      private:
         vector< BIT<T> > bit;
         int len;
      public:
         BIT_2D(int n) {
            len = n+1;
            bit.resize(len, BIT<T>(n));
         }
         void add(int i, int j, int x) {
            i += 1;
            while (i < len) {
               bit[i].add(j, x);
               i += i & -i;
            }
         }
         int sum(int i, int j) {
            i += 1;
            int s = 0;
            while (i > 0) {
               s += bit[i].sum(j);
               i -= i & -i;
            }
            return s;
         }
   };


###########################################################
#### SegmentTree                                       ####
###########################################################

snippet SegmentTree
   template<typename T> class SegmentTree
   {
      private:
         int n;
         vector<T> node;
      public:
         SegmentTree(vector<T> v) {
            int sz = v.size();
            n = 1; while(n < sz) n *= 2;
            node.resize(2*n-1);

            for(int i=0; i<sz; i++) node[i+n-1] = v[i];
            for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);
         }
         void update(int x, T val) {
            x += (n - 1);
            node[x] = val;
            while(x > 0) {
               x = (x - 1) / 2;
               node[x] = min(node[2*x+1], node[2*x+2]);
            }
         }
         int getmin(int a, int b, int k=0, int l=0, int r=-1) {
            // return min in [a, b)
            if(r < 0) r = n;
            if(r <= a || b <= l) return INF;
            if(a <= l && r <= b) return node[k];
            int vl = getmin(a, b, 2*k+1, l, (l+r)/2);
            int vr = getmin(a, b, 2*k+2, (l+r)/2, r);
            return min(vl, vr);
         }
   };

###########################################################
#### TRIE                                              ####
###########################################################

snippet Trie
   struct Node {
      Node* child[2];
      Node() {
         child[0] = nullptr;
         child[1] = nullptr;
      }
   };
   class Trie {
      private:
         Node* root;
      public:
         Trie() {
            root = new Node();
         }
         void insert(string str) {
            Node* cur = root;
            for (int i = 0; i < str.size(); i++) {
               int x = str[i] - '0';
               if (cur->child[x] == nullptr) {
                  cur->child[x] = new Node();
               }
               cur = cur->child[x];
            }
         }
   };


###########################################################
#### GRAPH THEORY                                      ####
###########################################################

snippet add_edge
   template<typename T>
   void add_edge(vector< vector<edge> >& G, int u, int v, T c) {
      G[u].push_back((edge){ u, v, c });
      G[v].push_back((edge){ v, u, c });
   }
   template<typename T>
   void add_edge(vector<edge>& E, int u, int v, T c) {
      E.push_back((edge){ v, u, c });
   }

snippet dfs
   void dfs(const vector< vector<edge> >& G, vector<bool>& used, int s) {
      stack<int> st;
      if (!used[s]) st.push(s);
      while (!st.empty()) {
         int i = st.top(); st.pop();
         for(int j = 0; j < G[i].size(); j++) {
            edge e = G[i][j];
            // ...
            if (!used[e.to]) {
               used[e.to] = true;
               st.push(e.to);
            }
         }
      }
   }

snippet bfs
   void bfs(const vector< vector<edge> >& G, vector<bool>& used, int s) {
      queue<int> que;
      if (!used[s]) que.push(s);
      while (!que.empty()) {
         int i = que.front(); que.pop();
         for(int j = 0; j < G[i].size(); j++) {
            edge e = G[i][j];
            // ...
            if (!used[e.to]) {
               used[e.to] = true;
               que.push(e.to);
            }
         }
      }
   }

snippet dijkstra
   template<typename T>
   void dijkstra(const vector< vector<edge> >& G, vector<T>& d, int s)
   {
      priority_queue<P<T,int>, vector<P<T,int>>, greater<P<T,int>> > que;
      fill(d.begin(), d.end(), INF);
      d[s] = 0;
      que.push(make_pair(0, s));
      while(!que.empty()) {
         T temp_cost = que.top().first;
         int from = que.top().second;
         que.pop();
         if (d[from] < temp_cost) continue;
         for (int i = 0; i < G[from].size(); i++) {
            edge e = G[from][i];
            if (d[e.to] > d[from] + e.cost) {
               d[e.to] = d[from] + e.cost;
               que.push(make_pair(d[e.to], e.to));
            }
         }
      }
   }

snippet warshall_floyd
   void warshall_floyd(vector< vector<int> >& d)
   {
      int N = d.size();
      for (int k = 0; k < N; k++) {
         for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
               d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
            }
         }
      }
   }

snippet topological_sort
   void topological_sort(const vector<vector<int>>& G, vector<int>& idx)
   {
      vec<int> num(G.size(),0);
      REP(i, 0, G.size()) {
         REP(j, 0, G[i].size()) {
            num[G[i][j]]++;
         }
      }
      stack<int> st;
      for(int i = 0; i < num.size(); i++) {
         if (num[i] == 0) {
            st.push(i);
         }
      }
      int k = 0;
      while (!st.empty()) {
         int i = st.top(); st.pop();
         idx[i] = k;
         for(int j = 0; j < G[i].size(); j++) {
            num[G[i][j]]--;
            if (num[G[i][j]] == 0) {
               st.push(G[i][j]);
            }
         }
         k++;
      }
   }

snippet max_flow
   struct edge { int to, rev; int cap; };
   void add_edge(vector<vector<edge>>& G, int u, int v, int c) {
      G[u].push_back((edge){ v, G[v].size()  , c });
      G[v].push_back((edge){ u, G[u].size()-1, 0 });
   }
   int dfs(vector< vector<edge> >& G, vector<bool>& used, int v, int t, int flow)
   {
      if (v == t) return flow;
      used[v] = true;
      for(int i = 0; i < G[v].size(); ++i) {
         edge& e = G[v][i];
         if (used[e.to] || e.cap == 0) continue;
         int d = dfs(G, used, e.to, t, min(e.cap, flow));
         if (d > 0) {
            e.cap -= d;
            G[e.to][e.rev].cap += d;
            return d;
         }
      }
      return 0;
   }
   int max_flow(vector< vector<edge> >& G, int s, int t)
   {
      int flow = 0;
      vector<bool> used(G.size());
      for (;;) {
         fill(used.begin(), used.end(), false);
         int f = dfs(G, used, s, t, INF);
         if (f == 0) return flow;
         flow += f;
      }
   }

snippet prim
   int prim(const vector< vector<edge> >& G)
   {
      int sum = 0;
      vector<bool> used(G.size(), false);
      priority_queue<P<int,int>, vector<P<int,int>>, greater<P<int,int>> > que;
      que.push(make_pair(0, 0));
      while (!que.empty()) {
         int cost = que.top().first;
         int from = que.top().second;
         que.pop();
         if (used[from]) continue;
         used[from] = true;
         sum += cost;
         for (int i = 0; i < G[from].size(); i++) {
            edge e = G[from][i];
            if (!used[e.to]) {
               que.push(make_pair(e.cost, e.to));
            }
         }
      }
      return sum;
   }

snippet kruskal
   int kruskal(vector<edge>& E, vector< vector<edge> > G, vector<bool>& used) {
      UnionFind uni(G.size());
      SORT(E);
      int sum = 0;
      for(int i = 0; i < E.size(); i++) {
         edge e = E[i];
         if (!uni.same(e.from, e.to)) {
            uni.unite(e.from, e.to);
            sum += e.cost;
            used[i] = true;
         }
      }
      return sum;
   }

snippet UnionFind
   class UnionFind
   {
      private:
         vector<int> par, myrank;
      public:
         UnionFind(int n) {
            par.resize(n);
            myrank.resize(n, 0);
            for (int i = 0; i < n; i++) {
               par[i] = i;
            }
         }
         int find(int x) {
            if (par[x] == x) return x;
            return par[x] = find(par[x]);
         }
         void unite(int x, int y) {
            x = find(x);
            y = find(y);
            if (x == y) return;
            if (myrank[x] < myrank[y]) {
               par[x] = y;
            } else {
               par[y] = x;
               if(myrank[x] == myrank[y]) myrank[x]++;
            }
         }
         bool same(int x, int y)
         {
            return find(x) == find(y);
         }
   };


###########################################################
#### MATRIX                                            ####
###########################################################

snippet Matrix
   template<typename T> class Matrix
   {
      private:
         vector<vector<T>> val;
         int m, n;
      public:
         Matrix(int a=0, int b=0) : m(a), n(b) {
            val.resize(m, vector<T>(n));
         }
         Matrix(const vector<vector<T>>& vec) : m(vec.size()), n(vec[0].size()) {
            val.resize(m, vector<T>(n));
            for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] = vec[i][j];
         }
         ~Matrix() {
            vector<vector<T>>().swap(val);
         }
         Matrix& operator=(const Matrix& mat) {
            try { if (m != mat.m || n != mat.n) throw "Matrix can't be substituted"; }
            catch (const char* e) { cerr << e << endl; }
            for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] = mat.val[i][j];
            return *this;
         }
         T operator()(int i, int j) {
            try { if (i < 0 || m <= i || j < 0 || n <= j) throw "Bad access"; }
            catch (const char* e) { cerr << e << endl; }
            return val[i][j];
         }
         const Matrix operator+(const Matrix& mat) const {
            try { if (m != mat.m || n != mat.n) throw "Matrix can't be added"; }
            catch (const char* e) { cerr << e << endl; }
            Matrix tmp(m, n);
            for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) tmp.val[i][j] = val[i][j] + mat.val[i][j];
            return tmp;
         }
         const Matrix operator-(const Matrix& mat) const {
            try { if (m != mat.m || n != mat.n) throw "Matrix can't be added"; }
            catch (const char* e) { cerr << e << endl; }
            Matrix tmp(m, n);
            for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) tmp.val[i][j] = val[i][j] - mat.val[i][j];
            return tmp;
         }
         const Matrix operator*(const Matrix& mat) const {
            try { if (n != mat.m) throw "Matrix can't be producted"; }
            catch (const char* e) { cerr << e << endl; }
            Matrix tmp(m, mat.n);
            for (int i = 0; i < m; i++) for (int j = 0; j < mat.n; j++) for (int k = 0; k < n; k++) tmp.val[i][j] += val[i][k]*mat.val[k][j];
            return tmp;
         }
         Matrix& operator+=(const Matrix& mat) {
            try { if (m != mat.m || n != mat.n) throw "Matrix can't be added"; }
            catch (const char* e) { cerr << e << endl; }
            for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] += mat.val[i][j];
            return *this;
         }
         Matrix& operator-=(const Matrix& mat) {
            try { if (m != mat.m || n != mat.n) throw "Matrix can't be added"; }
            catch (const char* e) { cerr << e << endl; }
            for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) val[i][j] -= mat.val[i][j];
            return *this;
         }
         Matrix operator*=(const Matrix& mat) {
            try { if (n != mat.m) throw "Matrix can't be producted"; }
            catch (const char* e) { cerr << e << endl; }
            Matrix tmp(m, mat.n);
            for (int i = 0; i < m; i++) for (int j = 0; j < mat.n; j++) for (int k = 0; k < n; k++) tmp.val[i][j] += val[i][k]*mat.val[k][j];
            n = mat.n;
            val.resize(m, vector<T>(n));
            *this = tmp;
            return *this;
         }
         Matrix transpose() const {
            Matrix tmp(n, m);
            for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) tmp.val[j][i] = val[i][j];
            return tmp;
         }
         Matrix gaussElimination() const {
            Matrix<T> A(val);
            int col = 0;
            for (int i = 0; i < m; i++) {
               int pivot = i;
               while (true) {
                  for (int j = i+1; j < m; j++) if (abs(A.val[j][col]) > abs(A.val[pivot][col])) pivot = j;
                  if (A.val[pivot][col] == 0) {
                     col++;
                     if (col == n) return A;
                  } else break;
               }
               swap(A.val[i], A.val[pivot]);
               for (int j = i+1; j < m; j++) {
                  T ratio = A.val[j][col] / A.val[i][col];
                  for (int k = col; k < n; k++) A.val[j][k] -= A.val[i][k] * ratio;
               }
               col++;
            }
            return A;
         }
         int rank() const {
            Matrix A = gaussElimination();
            int j = 0;
            for (int i = 0; i < m; i++) {
               while (A.val[i][j] == 0) {
                  j++; if (j == n) return i;
               }
            }
            return m;
         }
         ostream& info(ostream& s) const {
            s << endl << "[";
            for (int i = 0; i < m; i++) {
               s << "[";
               for (int j = 0; j < n; j++) {
                  s << val[i][j];
                  if (j < n-1) s << " ";
               }
               s << "]"; if (i < m-1) s << endl;
            }
            s << "]";
            return s;
         }
   };
   template<typename T> ostream& operator<<(ostream& s, const Matrix<T>& mat) {
      mat.info(s);
      return s;
   }

snippet SquareMatrix
   template<typename T> class SquareMatrix : public Matrix<T>
   {
      private:
         int num;
      public:
         SquareMatrix(int a=0) : Matrix<T>(a, a) { num = a; }
         SquareMatrix(const vector<vector<T>>& vec) : num(vec.size()), Matrix<T>(vec) { 
            try { if (vec.size() != vec[0].size()) throw "Matrix isn't square matrix"; }
            catch (const char* e) { cerr << e << endl; }
         }
         T determinant() {
            Matrix<T> A = this->gaussElimination();
            T det = 1;
            for (int i = 0; i < num; i++) det *= A(i,i);
            return det;
         }
   };


###########################################################
#### STRING                                            ####
###########################################################

snippet suffix_array
   void construct_suffix_array(const string& str, vector<int>& sa) {
      int N = str.size();
      vector<int> rank(N+1);
      for (int i = 0; i <= N; i++) {
         rank[i] = i < N ? str[i] : -1;
      }
      vector<pair<pair<int,int>,int>> doub(N+1);
      for (int k = 1; k <= N; k *= 2) {
         for(int i = 0; i <= N; i++) {
            if (i+k < N+1) doub[i] = make_pair(make_pair(rank[i],rank[i+k]),i);
            else           doub[i] = make_pair(make_pair(rank[i],        0),i);
         }
         sort(doub.begin(), doub.end());
         vector<int> tmp(N+1);
         tmp[doub[0].second] = 0;
         for(int i = 0; i < N; i++) {
            tmp[doub[i+1].second] = tmp[doub[i].second] + (doub[i+1].first == doub[i].first ? 0 : 1);
         }
         copy(tmp.begin(), tmp.end(), rank.begin());
      }
      for(int i = 0; i <= N; i++) sa[rank[i]] = i;
   }

snippet lcp_array
   void construct_lcp_array(const string& str, const vector<int>& sa, vector<int>& lcp) {
      int N = str.size();
      vector<int> rank(N+1);
      for(int i = 0; i < N+1; i++) {
         rank[sa[i]] = i;
      }
      int h = 0;
      for(int i = 0; i < N; i++) {
         int j = sa[rank[i]-1];
         if (h > 0) h--;
         while (i+h < N && j+h < N && str[i+h] == str[j+h]) {
            h++;
         }
         lcp[rank[i]-1] = h;
      }
   }

snippet Z_algorithm
   void Z_algorithm(string S, vector<int>& A) {
      // GET A[i]: the longest common prefix size of S and S[i:N-1]
      int N = SZ(S);
      A[0] = N;
      int i = 1, j = 0;
      while (i < N) {
         while (i+j < N && S[j] == S[i+j]) j++;
         A[i] = j;
         if (j == 0) { i++; continue; }
         int k = 1;
         while (i+k < N && k+A[k] < j) { A[i+k] = A[k]; k++; }
         i += k; j -= k;
      }
   }

snippet rolling_hash
   int power(int x, int n) {
      int res = 1;
      while (n > 0) {
         if ((n & 1) == 1) res *= x;
         x *= x;
         n >>= 1;
      }
      return res;
   }
   vector<vector<unsigned long long>> H;
   void init_rolling_hash(const string& str) {
      int N = str.size();
      int M = log(N)/log(2);
      H.resize(0); H.resize(M+1);
      for (int m = 0; m < M; m++) {
         H[m].resize(N-(1LL<<m)+1, 0);
         for (int i = 0; i < 1LL<<m; i++) {
            H[m][0] += str[i] * power(MOD, (1LL<<m)-i-1);
         }
         for (int k = 0; k+(1LL<<m) < N; k++) {
            H[m][k+1] = H[m][k] * MOD - str[k] * power(MOD, 1LL<<m) + str[k+(1LL<<m)];
         }
      }
   }

###########################################################
#### WIP                                               ####
###########################################################

snippet BigNum
   class BigNum
   {
      private:
         int len;
         void carry() {
            FOR(i, 0, len-1) {
               vec[i+1] += vec[i] / 10;
               vec[i] %= 10;
            }
         }
      public:
         V<int> vec;
         BigNum(int n, string s="") {
            len = n;
            vec.resize(n);
            FOR(i, 0, s.size()) {
               vec[i] = s[s.size()-1-i] - '0';
            }
         }
         void add(int x) {
            vec[0] += x;
            carry();
         }
         void mul(int x) {
            FOR(i, 0, len) vec[i] *= x;
            carry();
         }
         void add(const BigNum& B, int k=0) {
            FOR(i, 0, B.len) vec[i+k] += B.vec[i];
            carry();
         }
         void mul(BigNum B) {
            BigNum A_copy(len), tmp(len);
            COPY(vec, A_copy.vec);
            fill(vec.begin(), vec.end(), 0);
            FOR(i, 0, B.len) {
               COPY(A_copy.vec, tmp.vec);
               tmp.mul(B.vec[i]);
               add(tmp, i);
            }
         }
   };

